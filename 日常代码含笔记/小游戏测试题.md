1.使用循环完成九九乘法表 要求为左对齐(如下所示)

```c
1*1=1
1*2=2  2*2=4
1*3=3  2*3=6  3*3=9
1*4=4  2*4=8  3*4=12 4*4=16
1*5=5  2*5=10 3*5=15 4*5=20 5*5=25
1*6=6  2*6=12 3*6=18 4*6=24 5*6=30 6*6=36
1*7=7  2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49
1*8=8  2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64
1*9=9  2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81
```

2.解释下列代码 头文件已经包含

```c

#define MAX_STUDENTS 50
#define NAME_LENGTH 20
#define PASS_SCORE 60.0

struct Student 
{
    int id;                 
    char name[NAME_LENGTH];
    float score;
    char grade;
};

struct Student students[MAX_STUDENTS];
int student_count = 0;

void show_menu() 
{
    printf("\n====== 主菜单 ======\n");
    printf("1. 添加学生\n");
    printf("2. 显示所有学生\n");
    printf("3. 查找学生\n");
    printf("4. 计算平均分\n");
    printf("5. 更新学生等级\n");
    printf("6. 按成绩排序\n");
    printf("7. 退出系统\n");
    printf("====================\n");
}

void add_student() 
{
    // 检查是否已满
    if(student_count >= MAX_STUDENTS) {
        printf("错误：学生数量已达上限！\n");
        return;
    }
    printf("\n--- 添加新学生 ---\n");
    printf("请输入学号: ");
    scanf("%d", &students[student_count].id);
    printf("请输入姓名: ");
    scanf("%s", students[student_count].name);
    printf("请输入成绩: ");
    scanf("%f", &students[student_count].score);
    if(students[student_count].score >= 90) 
    {
        students[student_count].grade = 'A';
    } 
    else if(students[student_count].score >= 80) 
    {
        students[student_count].grade = 'B';
    } 
    else if(students[student_count].score >= 70) 
    {
        students[student_count].grade = 'C';
    } 
    else if(students[student_count].score >= 60) 
    {
        students[student_count].grade = 'D';
    } 
    else 
    {
        students[student_count].grade = 'F';
    }
    
    student_count++;
    printf("学生添加成功！\n");
}

void show_all_students() 
{
    printf("\n--- 所有学生信息 ---\n");
    
    if(student_count == 0) 
    {
        printf("暂无学生信息！\n");
        return;
    }
    printf("学号\t姓名\t\t成绩\t等级\t状态\n");
    printf("--------------------------------------------\n");
    for(int i = 0; i < student_count; i++) 
    {
        char status[10];
        if(students[i].score >= PASS_SCORE) 
        {
            strcpy(status, "及格");
        } 
        else 
        {
            strcpy(status, "不及格");
        }
        
        printf("%d\t%s\t\t%.1f\t%c\t%s\n", 
               students[i].id, 
               students[i].name, 
               students[i].score, 
               students[i].grade,
               status);
    }
    printf("--------------------------------------------\n");
    printf("总计: %d 名学生\n", student_count);
}

void search_student() 
{
    int search_id;
    int found = 0;
    printf("\n--- 查找学生 ---\n");
    printf("请输入要查找的学号: ");
    scanf("%d", &search_id);
    for(int i = 0; i < student_count; i++) 
    {
        if(students[i].id == search_id) 
        {
            printf("\n找到学生信息：\n");
            printf("学号: %d\n", students[i].id);
            printf("姓名: %s\n", students[i].name);
            printf("成绩: %.1f\n", students[i].score);
            printf("等级: %c\n", students[i].grade);
            if(students[i].score >= PASS_SCORE) 
            {
                printf("状态: 及格\n");
            } 
            else 
            {
                printf("状态: 不及格\n");
            }
            
            found = 1;
            break;
        }
    }
    if(!found) 
    {
        printf("未找到学号为 %d 的学生！\n", search_id);
    }
}

void calculate_average() 
{
    if(student_count == 0) 
    {
        printf("暂无学生信息！\n");
        return;
    }
    float total = 0;
    int pass_count = 0;
    for(int i = 0; i < student_count; i++) 
    {
        total += students[i].score;
        
        if(students[i].score >= PASS_SCORE) 
        {
            pass_count++;
        }
    }
    float average = total / student_count;
    float pass_rate = (float)pass_count / student_count * 100;
    printf("\n--- 成绩统计 ---\n");
    printf("总人数: %d\n", student_count);
    printf("总分: %.1f\n", total);
    printf("平均分: %.1f\n", average);
    printf("及格人数: %d\n", pass_count);
    printf("不及格人数: %d\n", student_count - pass_count);
    printf("及格率: %.1f%%\n", pass_rate);
}

void update_grade() 
{
    printf("\n--- 更新学生等级 ---\n");
    
    for(int i = 0; i < student_count; i++)
    {
        // 根据新规则重新计算等级
        if(students[i].score >= 90) 
        {
            students[i].grade = 'A';
        } 
        else if(students[i].score >= 80) 
        {
            students[i].grade = 'B';
        } 
        else if(students[i].score >= 70) 
        {
            students[i].grade = 'C';
        } 
        else if(students[i].score >= 60) 
        {
            students[i].grade = 'D';
        } 
        else 
        {
            students[i].grade = 'F';
        }
    }
    printf("所有学生等级已更新！\n");
}

void sort_students() 
{
    if(student_count == 0) 
    {
        printf("暂无学生信息！\n");
        return;
    }
    printf("\n--- 按成绩从高到低排序 ---\n");
    for(int i = 0; i < student_count - 1; i++)
    {
        for(int j = 0; j < student_count - 1 - i; j++)
        {
            if(students[j].score < students[j + 1].score) 
            {
                struct Student temp = students[j];
                students[j] = students[j + 1];
                students[j + 1] = temp;
            }
        }
    }
    printf("排序完成！\n");
    show_all_students();
}

int main() 
{
    int choice;
    
    printf("=======================\n");
    printf("  学生成绩管理系统\n");
    printf("=======================\n");
    
    do {
        show_menu();
        printf("请输入选项 (1-7): ");
        scanf("%d", &choice);
        
        switch(choice) {
            case 1:
                add_student();
                break;
            case 2:
                show_all_students();
                break;
            case 3:
                search_student();
                break;
            case 4:
                calculate_average();
                break;
            case 5:
                update_grade();
                break;
            case 6:
                sort_students();
                break;
            case 7:
                printf("感谢使用，再见！\n");
                break;
            default:
                printf("无效选项，请重新输入！\n");
        }
        
        printf("\n");
    } while(choice != 7);
    
    return 0;
}
```

3.运行下面的Test会有什么问题

```c
void Getmemory(char* p)
{
    p = (char*)malloc(100);
}
void Test(void)
{
    char* str = NULL;
    Getmemory(str);
    strcpy(str, "hello world");
    printf(str);
}
```

4.运行下面的Test会有什么问题

```c
void GetMemory2(char** p, int num)
{
    *p = (char*)malloc(num);
}
void Test(void)
{
    char *str = NULL;
    GetMemory(&str, 100);
    strcpy(str, "hello");
    printf(str);
}
```

5.简述一下若需要实现五子棋的胜利判断 那么判断条件该怎么写比较好 (口述或代码实现)

```c

```
6.功能: 计算两个整数的最大公约数
参数:
    a: 第一个整数
    b: 第二个整数
返回值:
    两个整数的最大公约数

```c
int gcd(int a, int b) 
{

    //在这里写函数实现
    return 0;

}
```
7.
功能: 计算斐波那契数列的第k个数
参数:
    k: 在斐波那契数列中的位置(从1开始), k的值不大于40
返回值:
    斐波那契数列的第k个数的值

```c
int fibonacci(int k) 
{
    //在这里写函数实现
    return 0;
}
```
8.
    功能: 查找数组中第k大的元素
    参数:
        arr: 整数数组
        size: 数组的大小
        k: 需要查找的位置(从1开始)
    返回值:
        数组中第k大的元素

```c
int getKthLargest(int arr[], int size, int k) 
{
    //在这里写函数实现
    return 0;
}
```
9.
    功能: 登录验证
        检查输入的账号和密码是否与存储的数据匹配
    参数:
        accounts: 存储的账号数组
        passwords: 存储的密码数组(与账号对应)
        size: 传入数组的长度
        inputAccount: 用户输入的账号
        inputPassword: 用户输入的密码
    返回值:
        1: 登录成功
        0: 登录失败

```c
int login(int accounts[], int passwords[], int size, int inputAccount, int inputPassword) 
{
    //在这里写函数实现
}
```
10.
    功能: 日期验证
        传入年,月,日三个整数参数,判断这个日期是否合法.
        注意处理闰年的天数问题.
        闰年判断规则:
1.年份是4的倍数 -> 是闰年
2.年份是100的倍数 -> 不是闰年
3.但是,年份是400的倍数 -> 是闰年
参数
​       year: 年
​       month: 月
​       day: 日
​    返回值:
​        0: 日期错误
​        1: 日期正确

```c
int isValidDate(int year, int month, int day) 
{
    //在这里写函数实现
    return 0;
}
```

11.试着解释下列代码 函数已经声明 头文件也已经包含

```c
typedef int Element_t;
typedef struct _node
{
    Element_t val;
    struct _node* next;
}node_t;
typedef struct
{
    node_t head;
    int count;
}LinkList_t;

LinkList_t* creatLinkList()
{
    LinkList_t* table = NULL;
    table = (LinkList_t*)malloc(sizeof(LinkList_t));
    if (table == NULL)
    {
        perror("errno");
        return NULL;
    }
    table->head.val = 0;
    table->head.next = NULL;
    table->count = 0;
    return table;
}

void insertLinkListPos(LinkList_t* table, Element_t num, int where)
{
    assert(table);
    if (where < 0 || where > table->count)
    {
        printf("The position that you want to insert is wrong\n");
        return;
    }
    node_t* newNode = (node_t*)malloc(sizeof(node_t));
    if (newNode == NULL)
    {
        perror("errno");
        return;
    }
    newNode->val = num;
    newNode->next = NULL;
    if (where == 0)
    {
        newNode->next = table->head.next;
        table->head.next = newNode;
        table->count++;
    }
    node_t* prev = &table->head;
    for (int i = 0; i < where; i++)
    {
        prev = prev->next;
    }
    newNode->next = prev->next;
    prev->next = newNode;
    table->count++;
}

void test(void)
{
    LinkList_t* table = creatLinkList();
    if (table == NULL)
    {
        return -1;
    }
    for (int i = 0; i < 10; i++)
    {
        insertLinkListHeader(table, i + 100);
    }
    insertLinkListPos(table, 666, 5);
    showLinkList(table);
}

int main()
{
    test1();
    return 0;
}
```

